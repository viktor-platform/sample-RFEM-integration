import json
import sys
from pathlib import Path

import numpy as np
import pandas as pd
from RFEM.BasicObjects.material import Material
from RFEM.BasicObjects.member import Member
from RFEM.BasicObjects.node import Node
from RFEM.BasicObjects.section import Section
from RFEM.enums import LoadDirectionType
from RFEM.enums import NodalSupportType
from RFEM.initModel import Calculate_all
from RFEM.initModel import Model
from RFEM.LoadCasesAndCombinations.loadCase import LoadCase
from RFEM.LoadCasesAndCombinations.staticAnalysisSettings import StaticAnalysisSettings
from RFEM.Loads.memberLoad import MemberLoad
from RFEM.Loads.nodalLoad import NodalLoad
from RFEM.TypesForNodes.nodalSupport import NodalSupport


def get_dataframe_from_calculation_results(filename="LC1_static_analysis_members_internal_forces.csv") -> list:
    """Locate the path to the calculation results and returns an array of dataframes.

    Args:
        filename (str, optional): Filename of the calculation results generated by RFEM. Defaults to "LC1_static_analysis_members_internal_forces.csv".

    Returns:
        list: List of dataframes.
    """
    path = Path(__file__).parent / "demo" / filename
    df = pd.read_csv(path, sep=";", skiprows=[0])  # Skip the first row for it is empty
    return np.split(df, df[df.isnull().all(1)].index)  # Split the dataframe on empty rows


def add_forces(model: dict) -> dict:
    """Add the internal forces of each member to the model dict."""
    # read the csv
    df_list = get_dataframe_from_calculation_results()

    # parse the df
    for df, member in zip(df_list[:-2], model["members"]):
        df = df.drop(df[df.isnull().all(1)].index)  # drop empty rows
        df = pd.Series(df.values[-1], index=df.columns)
        force = dict()
        index = df.index[4:10]  # Values we want to use
        for key in index:
            force[key] = df[key]
        member["force"] = force

    return model


def read_summary() -> dict:
    """Read the csv that is generated by the export_result_tables_to_csv method and reformat it for easy processing."""

    # read the csv
    file = "LC1_static_analysis_summary.csv"
    path = Path(__file__).parent / "demo" / file
    df = pd.read_csv(path, sep=";", skiprows=[0], usecols=range(1, 5))  # Skip the first row and column for it is empty
    header = ["Description", "Value", "Unit", "Notes"]  # Header for the summary

    # split the summary csv in different dataframes
    tables = ["Loads", "Reactions", "Deformations", "Statistics"]  # Names of the tables we are going to create
    df_list = np.split(df, df[df.isnull().all(1)].index)  # Split the dataframe on empty rows
    summary = dict()
    for df, table in zip(df_list[:-1], tables):
        df = df.drop(df[df.isnull().all(1)].index)  # drop empty rows
        df = pd.DataFrame(df.values[1:], columns=header)  # rebuild the dataframe so we have the correct column labels
        item = dict()
        for _, row in df.iterrows():
            item[f"{row['Description']} [{row['Unit']}]"] = row[
                "Value"
            ]  # Format the dataframe so we can read it easily later
        summary[table] = item

    return summary


def write_output_json(data: dict) -> None:
    """Dumps the data to the output.json for the worker."""
    output = json.dumps(data, indent=4)
    path = Path(__file__).parent / "output.json"
    with open(path, "w") as outfile:
        outfile.write(output)


def create_output_forces(model: dict) -> None:
    """Creats the output.json with the forces per member so
    the VIKTOR worker can send it back to the application.
    """
    # forces
    model = add_forces(model)

    # info
    service = Model.clientModel.service
    modelStatus = service.get_model_info()
    model["info"] = {
        "Nodes": modelStatus.property_node_count,
        "Members": modelStatus.property_member_count,
        "Weight": modelStatus.property_weight,
        "Cost Estimation": modelStatus.property_cost_estimation,
    }

    # summary
    model["summary"] = read_summary()

    # Write output.json
    write_output_json(model)


def get_max_force(model: dict) -> dict:
    """Get the max force per section."""
    df_list = get_dataframe_from_calculation_results("LC1_static_analysis_members_internal_forces_by_section.csv")

    # parse the df
    result = dict()
    for df, section in zip(df_list[:-2], model["sections"]):
        df = df.drop(df[df.isnull().all(1)].index)  # drop empty rows
        df = pd.Series(df.values[-1], index=df.columns)
        result[section["tag"]] = {"material": section["material"], "N": df.loc["N"]}

    return result


def build_model(model: dict):
    """When the RFEM webservice is running this function will create a model inside RFEM."""
    # RFEM functionality
    Model.clientModel.service.begin_modification()  # Enable editting on the model
    for material in model["materials"]:
        Material(material["tag"], material["name"])

    # Create sections
    for section in model["sections"]:
        Section(section["tag"], section["material"])

    # Create nodes and members
    tag_nodes = []
    for node in model["nodes"]:
        Node(node["tag"], node["x"], node["y"], -node["z"])
        tag_nodes.append(node["tag"])
    for member in model["members"]:
        Member(
            member["tag"],
            member["start_node"],
            member["end_node"],
            member["rotation_angle"],
            member["start_section"],
            member["end_section"],
        )

    # Create supports
    NodalSupport(1, f"{tag_nodes[-2]} {tag_nodes[-1]}", NodalSupportType.FIXED)

    # Settings
    StaticAnalysisSettings.GeometricallyLinear(1, "Linear")
    StaticAnalysisSettings.SecondOrderPDelta(2, "SecondOrder")
    StaticAnalysisSettings.LargeDeformation(3, "LargeDeformation")

    # Loads for simulation
    simulation = model["simulation"]
    if "Self-Weight" in simulation:
        self_weight = simulation["Self-Weight"]
        LoadCase(self_weight["tag"], "Self-Weight", [True, 0.0, 0.0, 1])
        NodalLoad(
            self_weight["tag"],
            self_weight["tag"],
            f"{tag_nodes[0]}-{tag_nodes[-1]}",
            LoadDirectionType.LOAD_DIRECTION_LOCAL_Z,
            self_weight["force"] * 1000,
        )
    if "Member load" in simulation:
        member_load = simulation["Member load"]
        LoadCase(member_load["tag"], "Member Load", [True, 0.0, 0.0, 1])
        MemberLoad(
            member_load["tag"],
            member_load["tag"],
            "1",
            LoadDirectionType.LOAD_DIRECTION_LOCAL_Z,
            member_load["force"] * 1000,
        )

    Model.clientModel.service.finish_modification()  # Disable editting on the model


def main(model: dict, selection: int = 0) -> None:
    """This script builds the model in RFEM using a json. It also creates an output.json for
    the worker."""
    Model(True, "demo", delete=True, delete_all=True)  # create new model called demo
    if selection == 0:
        build_model(model)
        Calculate_all()
        path = Path(__file__).parent
        Model.clientModel.service.export_result_tables_to_csv(path)
        create_output_forces(model)
    elif selection == 1:
        models = model
        results = []
        for model in models:
            Model.clientModel.service.delete_all_results()
            Model.clientModel.service.delete_all()
            build_model(model)
            Calculate_all()
            path = Path(__file__).parent
            Model.clientModel.service.export_result_tables_to_csv(path)
            results.append(get_max_force(model))
        write_output_json(results)


if __name__ == "__main__":
    with open(Path(__file__).parent / "input.json", "r") as f:
        model = json.load(f)

    main(model, int(sys.argv[1]))
