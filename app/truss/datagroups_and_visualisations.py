import math

import numpy as np
import pandas as pd
from munch import Munch

from viktor.views import DataGroup
from viktor.views import DataItem

from .constants import material_allowed_stress
from .model import Truss
from .model import unity_check


def build_model_from_params(params: Munch) -> Truss:
    """Parsing the params to get a model"""

    # Number of truss panels depending on height and length
    length = params.step_design.frame.length
    height_panels = params.step_design.frame.height_panels
    truss_panels = np.ceil(length / height_panels)

    # Simulation parameters to add load on the RFEM model
    simulation = dict()
    simulation["Member load"] = {"tag": 1, "force": params.step_design.loads_materials.member_load}

    # Returning the model
    return Truss(
        length=length,
        height=params.step_design.frame.height,
        height_panels=height_panels,
        truss_panels=truss_panels,
        simulation=simulation,
        sections=[
            params.step_design.sections.material1,
            params.step_design.sections.material2,
            params.step_design.sections.material3,
            params.step_design.sections.material4,
        ],
        materials=[params.step_design.loads_materials.material],
    )


def create_datagroup(model_dict: dict, safety_factor: float = 1) -> DataGroup:
    """Creates a datagroup from the information on the model that RFEM has calculated.

    Args:
        model_dict (dict): The dictionary made by the worker.
        safety_factor (float, optional): Will be multiplied by the material to reduce the allowed stress.

    Returns:
        DataGroup: The DataGroup used in the DataView.
    """
    # Basic info
    info = model_dict["info"]
    info_items = []
    for key, val in info.items():
        info_items.append(DataItem(key, val, number_of_decimals=2))
    info = DataItem("Info", "Basic information about the model", subgroup=DataGroup(*info_items))
    # Summary
    summary = model_dict["summary"]
    descriptions = [
        "Sum of loads and the sum of support forces",
        "Resultant of reactions",
        "Maximum deformations",
        "Calculation statitic",
    ]
    summary_items = []
    for table, description in zip(summary, descriptions):
        subgroup_items = []
        for key, val in summary[table].items():
            subgroup_items.append(DataItem(key, val))
        summary_items.append(DataItem(table, description, subgroup=DataGroup(*subgroup_items)))
    summary = DataItem("Summary", "Summary generated by RFEM", subgroup=DataGroup(*summary_items))

    # Forces by section
    members = pd.json_normalize(model_dict["members"])
    df = pd.DataFrame(members)
    forces_by_section = []
    sections = []
    names = ["Chords", "Vertical members", "Diagonal members", "Columns"]
    for section, name in enumerate(names, 1):
        sub_df = df[df["start_section"] == section]
        N_max = sub_df["force.N"].max()
        N_min = sub_df["force.N"].min()
        if abs(N_max) >= abs(N_min):
            N = N_max
        else:
            N = N_min
        forces_by_section.append(N)
        sections.append(DataItem(name, float(N) if not math.isnan(N) else None, number_of_decimals=2))
    forces = DataItem("Forces [kN]", "Max/min forces by section", subgroup=DataGroup(*sections))
    # Unity check by section
    unity_checks = []
    material = model_dict["materials"][0]["name"]
    allowed_stress = material_allowed_stress[material]["low"] * 1e6  # Pa = N/m^2
    allowed_stress *= safety_factor
    for (idx, force), name in zip(enumerate(forces_by_section, 0), names):
        section_name = model_dict["sections"][idx]["material"]
        uc_val = unity_check(force, section_name, allowed_stress)
        unity_checks.append(DataItem(name, uc_val if not math.isnan(uc_val) else None, number_of_decimals=2))
    uc_dataitem = DataItem("Unity Check", "Unity check by section", subgroup=DataGroup(*unity_checks))

    return DataGroup(info=info, summary=summary, forces=forces, uc_dataitem=uc_dataitem)
